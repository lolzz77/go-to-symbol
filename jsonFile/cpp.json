{
    "function" : {
        "regexes" : [
            {
                "comment0" : "1st group matching has to be `1 or more`, tho my 1st group matching is for `static` those kind. But, regex matches from lef to right. Thus, for function that doesn't have `static`, and if i put my 1st group matching to `zero or more`, it will matches the 1st group matching. Thus, you should NOT set 1st group matching to `zero or more`. You should treat the 1st matching as `return type`. Thus, if you found a new function has more symbols before the `return type`, add them before the `(` in the regex, and put them `zero or more`.",
                "comment1" : "CANNOT be null. 1st group matching is `inline|static` etc  (note: i put `1 or more`, please read above comment why). Then is words like `unsigned` etc. Then is function return type like `int`. Then compulsory white space. Then function name, then optional whitespace. Then match `(`, then match anything not equal to ), then match match {.",
                "regex" : ["([a-zA-Z0-9_*]+)\\s+([a-zA-Z0-9_*]+)\\s*([a-zA-Z0-9_*]*)\\s*([a-zA-Z0-9_*]*)\\s*\\([^)]*\\)\\s*\\{", "g"],
                "comment2" : "Can be null. This operation is to tell my code how should i handle it. Currently has 'depth', 'remove', ''. depth - i will perform depth search, will use 'opening' key. 'remove' - will perform operation to remove it from buffered text, will not print on the tree list. '' - will fall into else case",
                "operation" : "depth",
                "comment3" : "Can be null. This tells my code, what is the opening & closing symbols. For depth searching.",
                "opening" : ["{", "}"],
                "comment4" : "Can be null. Can be either `before` or `after`. Can be multiple. If multiple, will search for the closest index. This is for cases that have either, eg: global variable, a symbol name can be before `=` or `;`. This tells my code, what symbol to look for to extract the symbol name.",
                "before" : ["("],
                "comment5" : "true/false. True - will print out in the list even if it is commented. False - will not print out in the list if it is commented. This tells my code, if it is commented, ignore it, print it out onto the list. Note: initially intended for MACRO regex. Havent test for other regex. Might be not working for others. Havent test.",
                "ignoreCommentedCode" : false
            }
        ]
    },
    "class" : {
        "regexes" : [
            {
                "comment1" : "",
                "regex" : ["^\\s*class\\s+\\w+\\s*\\{", "gm"],
                "operation" : "depth",
                "opening" : ["{", "}"],
                "before" : ["("],
                "ignoreCommentedCode" : false
            }
        ]
    },
    "union" : {
        "regexes" : [
            {
                "comment1" : "",
                "regex" : ["([typedef]*)\\s*union\\s*[a-zA-Z0-9_]*\\s*\\{", "g"],
                "operation" : "depth",
                "opening" : ["{", "}"],
                "before" : ["{"],
                "ignoreCommentedCode" : false
            }
        ]
    },
    "struct" : {
        "regexes" : [
            {
                "comment1" : "",
                "regex" : ["([typedef|extern]*)\\s*struct\\s*[a-zA-Z0-9_]*\\s*\\{", "g"],
                "operation" : "depth",
                "opening" : ["{", "}"],
                "before" : ["{"],
                "ignoreCommentedCode" : false
            }
        ]
    },
    "enum" : {
        "regexes" : [
            {
                "comment1" : "",
                "regex" : ["([typedef|extern]*)\\s*enum\\s+[^{}]*\\{", "g"],
                "operation" : "depth",
                "opening" : ["{", "}"],
                "before" : ["{"],
                "ignoreCommentedCode" : false
            }
        ]
    },
    "macro" : {
        "regexes" : [
            {
                "comment1" : "",
                "regex" : ["#define\\s+([^\\n]+)\\n", "g"],
                "operation" : "",
                "opening" : ["", ""],
                "after" : ["define"],
                "ignoreCommentedCode" : true
            }
        ]
    },
    "guard": {
        "regexes" : [
            {
                "comment1": "Match #ifdef|#ifndef words. 1st group match #ifdef|#ifndef. Then whitespace. Then the macro name. Then anything but newline. Then newline. Note: These regexes might not able to detect if this macro happened to put at end of document, without a newline at the end.",
                "regex": ["(#ifdef|#ifndef)\\s+([a-zA-Z0-9_*]+)([^\\n]*)\\n", "g"],
                "operation": "",
                "opening": ["", ""],
                "after": ["def"],
                "ignoreCommentedCode": true
            },
            {
                "comment1": "match define that uses () depth. 1st group match #if|#elif. Then whitespace. Then anything as long as not `defined`, cos sometime they put `!` in between. Then optional whitespace. Then anything except `(` and newline. Then `(`. TODO: Need fix the symbol naming",
                "regex": ["(#elif|#if)\\s+([^defined]*)\\s*([^\\(\\n]+)\\(([^\\)]+)\\)", "g"],
                "operation": "",
                "opening": ["", ""],
                "after": [")"],
                "ignoreCommentedCode": true
            },
            {
                "comment1": "match define that didnt use () depth",
                "regex": ["(#if)\\s+([^defined]*)\\s*([^\\n]+)\\n", "g"],
                "operation": "",
                "opening": ["", ""],
                "after": ["defined"],
                "ignoreCommentedCode": true
            }
        ]
    },
    "comment" : {
        "regexes" : [
            {
                "comment1" : "detects `//`. This will match til newline, despite in the comment has `\n`, it still can match. Note: to escape `/`(forward slash), you only need one `backslash`, not two",
                "regex" : ["\\s*\/\/.*", "g"],
                "operation" : "remove",
                "opening" : ["", ""],
                "before" : [""],
                "ignoreCommentedCode" : false,
                "comment2" : "History - means old regex, not using it anymore, but just put here for memories. Detects both `//` and multiline `/**/` comments. however, this detects '//' first. This can cause problem when there's `//` inside `/**/`, then it will detects `//` isnide of it first",
                "history" : ["\\/\\/.*|\\/\\*[^*]*\\*+(?:[^\\/*][^*]*\\*+)*\\/\\n", "g"]
            },
            {
                "comment1" : "detects multiline `/**/` comments.",
                "regex" : ["\\s*\/\\*[^*]*\\*+(?:[^\/*][^*]*\\*+)*\/", "g"],
                "operation" : "remove",
                "opening" : ["", ""],
                "before" : [""],
                "ignoreCommentedCode" : false
            }
        ]
    },
    "function_prototype" : {
        "regexes" : [
            {
                "comment1" : "1st group matching is 'static' those kind (will be optional for this). 2nd group is function return type. 3rd group is function name. Then match parenthesis. Then match ';'",
                "regex" : ["([a-zA-Z0-9_*]*)\\s*([a-zA-Z0-9_*]+)\\s+([a-zA-Z0-9_*]+)\\s*\\([^)]*\\)\\s*;", "g"],
                "operation" : "remove",
                "opening" : [""],
                "before" : [""],
                "ignoreCommentedCode" : false
            }
        ]
    },
    "include" : {
        "regexes" : [
            {
                "comment1" : "",
                "regex" : ["#include\\s+([^\\n]+)\\s*\\n", "g"],
                "operation" : "remove",
                "opening" : [""],
                "before" : [""],
                "ignoreCommentedCode" : false
            }
        ]
    },
    "global" : {
        "regexes" : [
            {
                "comment1" : "This is for global vairbale that is an array, thus, it has depth. Note: These global variable, can omit the `;` at the end.",
                "comment2" : "1st group matches return type. Then compulsory whitespace. Then variable name. Then optional white space. Then optional whitespace. Then anything until `=` or newline. Then match `=`. Then optional whitespace. Then `{`",
                "regex" : ["([a-zA-Z0-9_*]+)\\s+([a-zA-Z0-9_*]+)\\s*[^=\\n]*=\\s*\\{", "g"],
                "operation" : "depth",
                "opening" : ["{", "}"],
                "before" : ["="],
                "ignoreCommentedCode" : false
            },
            {
                "comment1" : "Match return type. Then whitespace. Then match variable name. Then match anything except ';' (zero or more, for cases `int x;` will fail the regex). Finally, match ';'",
                "comment2" : "this regex has some flaw. Last part, it says match til you see `;` and `}`. If saw `}` first, then it will exit. Then it will match `;`. However, in some cases, a global variable may be an array, and inside the global variable, it conatins `}`. Then, after `}`, may contain other things, only then last part is `;`. However, good thing is that it wont stuck in a loop. Solution: I create antoher global regex above of this.",
                "regex" : ["([a-zA-Z0-9_*]+)\\s+([a-zA-Z0-9_*]+)\\s*[^;}]*;", "g"],
                "operation" : "",
                "opening" : ["", ""],
                "before" : ["=", ";"],
                "ignoreCommentedCode" : false
            }
        ]
    }
}